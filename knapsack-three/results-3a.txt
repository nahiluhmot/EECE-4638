Tom Hulihan & Todd Lunter

For this iteration of the knapsack problem, we used AMPL to solve it.
AMPL takes a problem description as input, and outputs a Linear Programming (LP) problem.
This problem is then given to a LP solver, like cplex.
The goal of the knapsack problem is to maximize the value store in the knapsack, and the syntax for that was fairly straightforward:

    maximize sumOfValues: sum{i in 0..n-1} value[i] * isIncluded[i];

Here, `i` represents the id of each element, `value[i]` represents the value of that element, and `isIncluded[i]` is a binary that tells whether or not that value was included.
In addition to maximizing the value stored in the knapsack, we must also ensure that the bag does not exceed its cost bound.
The syntax to describe this was fairly similar to the maximization objective:

    subject to costBoundIsNotExceeded: sum{i in 0..n-1} cost[i] * isIncluded[i] <= costBound;

Similarly, `cost[i]` holds the cost of the item with id `i`.

We found that the results generated by LP for the knapsack problew were far better than those generated by greedy programming.
This is because greedy programming only produces optimal results for the fractional knapsack problem, while LP fits this problem better.
Also, using AMPL was far faster than the exhaustive search, although they generated similar results.


